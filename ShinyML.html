<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Interactive prediction with R Shiny</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="method-development-and-validation.html">LC-MS/MS</a>
</li>
<li>
  <a href="AIV_profile_analysis.html">AIV amino acids</a>
</li>
<li>
  <a href="Machine_learning_Classification.html">Machine learning</a>
</li>
<li>
  <a href="ShinyML.html">Interactive Shiny</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Interactive prediction with R Shiny</h1>

</div>


<p><br/><br/></p>
<div id="visit-our-shiny-app-for-interactive-machine-learning." class="section level4">
<h4>Visit our <strong><a href="https://boyuan.shinyapps.io/AIV_Classifier/">Shiny App</a></strong> for interactive machine-learning.</h4>
<div id="this-section-only-documents-the-corresponding-script-used-for-the-shiny-app." class="section level5">
<h5>This section only documents the corresponding script used for the Shiny app.</h5>
<p><br/><br/></p>
<pre class="r"><code>library(shiny)
library(DT)
library(rdrop2)
library(e1071)
library(MASS)
library(glmnet)
library(randomForest)
library(caret)
library(readxl)
library(writexl)
library(tidyverse)
library(ComplexHeatmap) # from bionconductor
library(circlize)

library(BiocManager) # ensure smooth use of ComplexHeatmap
options(repos = BiocManager::repositories())

# Import data from Dropbox ----
drop_auth()
token = drop_auth()
saveRDS(token, file = &quot;token.rds&quot;)

df.content = drop_read_csv(file = &quot;Dropbox AA Content Data.csv&quot;) 

# select needed columns and tidy up
df.content = df.content %&gt;% select(Name, Category, Site) %&gt;%
    mutate(strata.group = paste(Category, Site, sep = &quot;_&quot;)) %&gt;%
    cbind(df.content %&gt;% select(23:ncol(df.content))) %&gt;%
    as_tibble()

# categories
unique.categories = df.content$Category %&gt;% unique()



# Define functions ----
# Statified sampling
# strata group
unique.categories.site = df.content$strata.group %&gt;% unique()

# Define function doing stratified sampling based on category-site combination 
func.stratifiedSampling = function(trainingRatio = 0.7){
    
    df.train = sample_frac(df.content, size = trainingRatio, replace = F)
    df.test = df.content %&gt;% anti_join(df.train, by = &quot;Name&quot;)
    
    list.learn = list(df.train, df.test)
    return(list.learn)
}



## Normalization  ----
# input list: 1st: training set; 2nd, test set; i.e., the output of func.stratifiedSampling
func.normalize.trainTest = function(list) { 
    
    mat.train = list[[1]] %&gt;% dplyr::select(-c(Name, Category, Site, strata.group, `Data.File`)) %&gt;% as.matrix()
    mat.test = list[[2]] %&gt;% dplyr::select(-c(Name, Category, Site, strata.group, `Data.File`)) %&gt;% as.matrix()
    
    # mean vector computed from training set (as single column matrix)
    meanVector.train = apply(mat.train, 2, mean) %&gt;% as.matrix()
    
    # diagonol matrix, with standard deviation inverse
    mat.inverse.sd.diaganol = apply(mat.train, 2, sd)  %&gt;% diag() %&gt;% solve()
    # Reserve column names
    colnames(mat.inverse.sd.diaganol) = colnames(mat.train) 
    
    # ones vector, as single column matrix, length = # observation units of TRAINING set
    vector.ones.train = rep(1, nrow(mat.train)) %&gt;% as.matrix()
    
    # Compute normalized training dataset 
    mat.train.scaled = (mat.train - vector.ones.train %*% t(meanVector.train)) %*% mat.inverse.sd.diaganol
    
    # Normalize test dataset using training-set mean vector and standard deviation diagonal matrix
    # ones vector, as single column matrix, length = # observation units of TESTING set 
    vector.ones.test = rep(1, nrow(mat.test)) %&gt;% as.matrix()
    mat.test.scaled = (mat.test - vector.ones.test %*% t(meanVector.train)) %*% mat.inverse.sd.diaganol
    
    # Complete two matrices with category labels, and convert to tibble
    df.train.scaled = cbind(data.frame(Category = list[[1]]$Category), mat.train.scaled) %&gt;% as_tibble()
    df.test.scaled  = cbind(data.frame(Category = list[[2]]$Category), mat.test.scaled) %&gt;% as_tibble()
    return(list(df.train.scaled, df.test.scaled))
}

# Chaining prior two functions
# 1) stratified sampling into training and test set
# 2) normalize training set, and normalize test set based on training mean vector and standard deviation 
func.strata.Norm.trainTest = function(trainingRatio = 0.7, scaleData = T){
    if(scaleData == T){
        func.stratifiedSampling(trainingRatio = trainingRatio) %&gt;%
            func.normalize.trainTest() %&gt;% return()
    } else {
        func.stratifiedSampling(trainingRatio = trainingRatio) %&gt;% return()
    }
}



# Prediction table tidy up ----
# Confusion matrix
# Define functions: tidy up confusion tables (contingency table and stats) 

# 1) For contigency table
func.tidy.cf.contigencyTable = function(inputTable, ModelName){
    inputTable %&gt;% as.data.frame() %&gt;% 
        spread(key = Reference, value = Freq) %&gt;% 
        mutate(Model = ModelName) %&gt;%
        return()
}

# 2) Summary statistics for each category
func.tidy.cf.statsTable = function(inputTable, ModelName){
    cbind(Category = rownames(inputTable), inputTable %&gt;% as_tibble()) %&gt;%
        mutate(Category = str_remove(Category, pattern = &quot;Class: &quot;)) %&gt;%
        mutate(Model = ModelName) %&gt;%
        return()
}

# 3) Summarize most votes form all models
func.mostVotes = function(vector){
    x = vector %&gt;% table() %&gt;% sort() %&gt;% rev() 
    names(x)[1] %&gt;% return()
}

# 4) Overal summary statistics for each model
func.tidy.cf.statsOveral = function(vector, modelName){
    d = data.frame(Accuracy = vector[1], AccuracyLower = vector[3], 
                   AccuracyUpper = vector[4], Model = modelName) %&gt;% as_tibble()
    return(d)
}


# arrange model order
unique.models = factor(c(&quot;LDA&quot;, &quot;QDA&quot;, &quot;EN&quot;, 
                         &quot;RF&quot;, &quot;SVM&quot;, &quot;NB&quot;, &quot;Most voted&quot;), ordered = T)

unique.models2 = factor(c(&quot;Linear discriminant analysis&quot;, &quot;Quadratic discriminant analysis&quot;, &quot;Elastic net&quot;, 
                          &quot;Random forest&quot;, &quot;Support vector machine&quot;, &quot;Naive Bayes&quot;, &quot;Most voted&quot;), ordered = T)


# Entire dataset summary stats (used for tabs #2 &amp; #3 single &amp; batch sample(s) prediction) -----
df.summaryALL = (df.content %&gt;% select(-c(Name, Site, Category, strata.group, Data.File))) %&gt;%
    gather(key = compounds, value = content) %&gt;%
    group_by(compounds) %&gt;%
    summarise(content.mean = mean(content),
              content.sd = sd(content)) 


# set up comounds as ordered factor
unique.compounds = (df.content %&gt;% colnames())[-c(1:5)]
unique.compounds = unique.compounds %&gt;% factor(levels = unique.compounds, ordered = T)


# In compound order as the input matrix
# This data provides the mean and standard deviation vector used for scale() function; normalization of the feature input of the unknown sample(s)
df.summaryALL = df.summaryALL %&gt;% 
    mutate(compounds = factor(compounds, level = unique.compounds, ordered = T)) %&gt;%
    arrange(compounds)


# AIV Category color
unique.categories = df.content$Category %&gt;% unique()

color.category = c(&quot;Black&quot;, &quot;Steelblue&quot;, &quot;Firebrick&quot; , &quot;Darkgreen&quot;) 
names(color.category) = unique.categories


# the computation progress bar
progress = c(&quot;Dataset setup&quot;, &quot;LDA&quot;, &quot;QDA&quot;, &quot;Elastic Net&quot;, &quot;Random Forest&quot;, &quot;SVM&quot;, &quot;Naive Bayes&quot;, &quot;Wrap up&quot;, &quot;Output&quot;)




# Define user interface ----
ui &lt;- fluidPage(
    
    # Application title
    titlePanel(strong(&quot;African Vegetables Classification Predictor&quot;)),
    
    # Sidebar with a slider input for number of bins 
    sidebarLayout(
        sidebarPanel(
            
            # tab 1 ----
            conditionalPanel( 
                &#39;input.purpose === &quot;Machine learning simulator&quot;&#39;,
                
                fluidRow(column(12, actionButton(inputId = &quot;Shuffle&quot;, 
                                                 label = &quot;  Train models and predict on test set&quot;, 
                                                 icon(&quot;paper-plane&quot;), 
                                                 style=&quot;color: white; background-color: steelblue; border-color: black&quot;))),
                
                # see icons at https://fontawesome.com/icons?from=io
                
                br(), br(),
                
                fluidRow(column(12, sliderInput(inputId = &quot;SplitRatio&quot;,
                                                label = &quot;Percent of data used for model training&quot;,
                                                min = .5, max = .9, value = .7))),
                
                fluidRow(column(12, checkboxInput(inputId = &quot;SeedBirthday&quot;, 
                                                  label = &quot;Set seed: generate reproducible split of train-test dataset&quot;, 
                                                  value = F))), 
                
                br(),br(),br(),
                strong(&quot;Model names are abbreviated as acronyms:&quot;), br(), br(),
                span(strong(&quot;LDA&quot;), &quot;, Linear Discriminant Analysis&quot;), br(),br(),
                span(strong(&quot;QDA&quot;), &quot;, Quadratic Discriminant Analysis&quot;), br(),br(),
                span(strong(&quot;EN&quot;), &quot;, Elastic Net (alpha = 0.5)&quot;), br(),br(),
                span(strong(&quot;RF&quot;), &quot;, Random Forest&quot;), br(),br(),
                span(strong(&quot;SVM&quot;), &quot;, Support Vector Machine&quot;), br(),br(),
                span(strong(&quot;NB&quot;), &quot;, Naive Bayes&quot;), br(), br()
            ),
            
            # tab 2 ----
            conditionalPanel(
                &#39;input.purpose === &quot;Unknown prediction: single sample&quot;&#39;,
                
                fluidRow(column(12, actionButton(inputId = &quot;Predict2&quot;, 
                                                 label = &quot; Predict!&quot;,
                                                 icon(&quot;cocktail&quot;), 
                                                 style=&quot;color: white; background-color: steelblue; border-color: black&quot;))),
                
                br(),
                
                fluidRow(column(4, sliderInput(&quot;alanine&quot;, &quot;alanine&quot;, min = 0, max = 1000, value = 529)),
                         column(4, sliderInput(&quot;arginine&quot;, &quot;arginine&quot;, min = 0, max = 1000, value = 176)),
                         column(4, sliderInput(&quot;asparagine&quot;, &quot;asparagine&quot;, min = 0, max = 5000, value = 2477))),
                
                fluidRow(column(4, sliderInput(&quot;aspartic.acid&quot;, &quot;aspartic acid&quot;, min = 0, max = 1000, value = 446)),
                         column(4, sliderInput(&quot;cysteine&quot;, &quot;cysteine&quot;, min = 0, max = 100, value = 2)),
                         column(4, sliderInput(&quot;glutamic.acid&quot;, &quot;glutamic acid&quot;, min = 0, max = 1000, value = 88))),
                
                fluidRow(column(4, sliderInput(&quot;glutamine&quot;, &quot;glutamine&quot;, min = 0, max = 1000, value = 465)),
                         column(4, sliderInput(&quot;glycine&quot;, &quot;glycine&quot;, min = 0, max = 1000, value = 72)),
                         column(4, sliderInput(&quot;histidine&quot;, &quot;histidine&quot;, min = 0, max = 1000, value = 136))),
                
                fluidRow(column(4, sliderInput(&quot;hydroxyproline&quot;, &quot;hydroxyproline&quot;, min = 0, max = 100, value = 5)),
                         column(4, sliderInput(&quot;isoleucine&quot;, &quot;isoleucine&quot;, min = 0, max = 1000, value = 175)),
                         column(4, sliderInput(&quot;leucine&quot;, &quot;leucine&quot;, min = 0, max = 1000, value = 136))),
                
                fluidRow(column(4, sliderInput(&quot;lysine&quot;, &quot;lysine&quot;, min = 0, max = 1000, value = 92)),
                         column(4, sliderInput(&quot;methionine&quot;, &quot;methionine&quot;, min = 0, max = 1000, value = 1.7)),
                         column(4, sliderInput(&quot;phenylalanine&quot;, &quot;phenylalanine&quot;, min = 0, max = 1000, value = 312))),
                
                fluidRow(column(4, sliderInput(&quot;proline&quot;, &quot;proline&quot;, min = 0, max = 5000, value = 1754)),
                         column(4, sliderInput(&quot;serine&quot;, &quot;serine&quot;, min = 0, max = 1000, value = 168)),
                         column(4, sliderInput(&quot;threonine&quot;, &quot;threonine&quot;, min = 0, max = 1000, value = 73))), # ----
                
                fluidRow(column(4, sliderInput(&quot;tryptophan&quot;, &quot;tryptophan&quot;, min = 0, max = 1000, value = 113)),
                         column(4, sliderInput(&quot;tyrosine&quot;, &quot;tyrosine&quot;, min = 0, max = 1000, value = 228)),
                         column(4, sliderInput(&quot;valine&quot;, &quot;valine&quot;, min = 0, max = 1000, value = 281)))
            ),
            
            # tab 3 ------
            conditionalPanel(
                &#39;input.purpose === &quot;Unknown prediction: batch sample&quot;&#39;,
                fluidRow(
                    column(
                        11,
                        downloadButton(&quot;downloadTemplate&quot;, &quot;Download table template for batch prediction&quot;,
                                       style=&quot;color: white; background-color: steelblue; border-color: black&quot;))
                ), 
                
                br(),
                
                fluidRow(
                    column(
                        11,
                        fileInput(inputId = &quot;userfile&quot;, label = NULL, buttonLabel = &quot;Browse...Excel input&quot;,
                                  width = &#39;700px&#39;, placeholder = &quot;Upload free amino acid content dataset&quot;))
                ),
                
                fluidRow(
                    column(
                        11, 
                        checkboxInput(inputId = &quot;ArrangeCategory&quot;, 
                                      label = &quot;Arrange heatmap predicted category by most voted results&quot;, 
                                      value = F))
                ), 
                
                fluidRow(
                    column(
                        11,
                        downloadButton(&quot;downloadPredicted&quot;, &quot;Download predicted result table&quot;,
                                       style=&quot;color: white; background-color: orange; border-color: black&quot;))
                ),
                
                br(),br(),br(),
                
                strong(&quot;Model names are abbreviated as acronyms:&quot;), br(), br(),
                span(strong(&quot;LDA&quot;), &quot;, Linear Discriminant Analysis&quot;), br(),br(),
                span(strong(&quot;QDA&quot;), &quot;, Quadratic Discriminant Analysis&quot;), br(),br(),
                span(strong(&quot;EN&quot;), &quot;, Elastic Net (alpha = 0.5)&quot;), br(),br(),
                span(strong(&quot;RF&quot;), &quot;, Random Forest&quot;), br(),br(),
                span(strong(&quot;SVM&quot;), &quot;, Support Vector Machine&quot;), br(),br(),
                span(strong(&quot;NB&quot;), &quot;, Naive Bayes&quot;), br(), br()
                
            )
            
        ),
        
        
        # Show a plot of the generated distribution
        mainPanel( 
            tabsetPanel(
                id = &#39;purpose&#39;,
                
                tabPanel(&quot;Machine learning simulator&quot;, # ------
                         br(),
                         fluidRow(
                             column(
                                 11,
                                 p(&quot;The African indigenous vegetables (AIVs) free amino acid dataset (544 rows, 21 columns) contains the content of 21 free amino acids in 544 samples of AIVs, the latter comprising four basic categories, i.e., nighthshades, amaranth, spider plant, and mustard. Each category was sourced from different continents or countries, harvest years and seasons, etc., including one or more subspecies and cultivars.&quot;, strong(&quot;This app makes prediction of the AIV category based on the content of free amino acids.&quot;,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  style = &quot;color: black&quot;)), br(),
                                 
                                 strong(&quot;Click&quot;, code(&quot;Train models and predict on test set&quot;), 
                                        &quot;button to train models using specified percent (default 70%) of the AIV amino acid dataset as the training set, and make predictions on the remaining percent of the dataset as the test set. The prediction result is summarized as the confusion matrix, showing counts of correct and incorrect predictions.&quot;, 
                                        style = &quot;color: steelblue&quot;),
                                 br(), br(),
                                 p(&quot;Following clicks of the button shuffles the dataset to create new training-testing sets, update models parameters, and refresh prediction results. After updating the training set percentage and seed setting, click the button again to initiate a new round of train and prediction.&quot;, 
                                   style = &quot;color:black&quot;),
                                 br(), br()
                             )
                         ),
                         
                         strong(&quot;A. The following confusion matrix presents the summarized prediction results vs. the actual.&quot;,
                                style = &quot;color:#006666&quot;),
                         
                         fluidRow(
                             column(8, plotOutput(&quot;plt.newShuffle&quot;))
                         ),
                         br(),br(),
                         
                         strong(&quot;B. The following heatmap presents the predicted result of each model vs. the actual on a sample-wise basis.&quot;,
                                style = &quot;color:#006666&quot;),
                         
                         fluidRow(
                             column(11, plotOutput(&quot;plt.newShuffle.heatmap&quot;))
                         ),
                         
                         br(),br(),
                         strong(&quot;C. The following sprout plot presents key summary statistics of each model.&quot;,
                                style = &quot;color:#006666&quot;),
                         p(&quot;The overal accuracy is in bold, with 95% confidence interval displayed in the following line.&quot;),
                         
                         fluidRow(
                             column(11, plotOutput(&quot;plt.summaryStats&quot;))
                         )
                ),
                
                tabPanel(&quot;Unknown prediction: single sample&quot;, # ------
                         br(),
                         
                         fluidRow(
                             column(
                                 11,
                                 p(&quot;This section makes prediction of AIV category of an unknown sample based on its free amino acid content (in unit of mg/100g dry weight), using models trained from the entire AIVs amino acid dataset (544 rows X 21 columns). The current default setting is the average level of free amino acids in African nightshade leaves.&quot;), br(),
                                 
                                 strong(&quot;Use sliderbars to update the amino acid content of a single unknown sample.&quot;), 
                                 br(),
                                 strong(&quot;Click&quot;, code(&quot;Predict!&quot;), &quot;to predict classfication based on updated feature space.&quot;)
                             )
                         ),
                         br(),
                         plotOutput(&quot;plt.singleSamplePredict&quot;)),
                
                tabPanel(&quot;Unknown prediction: batch sample&quot;, # ------
                         br(),
                         fluidRow(
                             column(
                                 11, 
                                 p(&quot;This section makes prediction of multiple samples using models trained from the entire AIV amino acid dataset.&quot;),
                                 strong(&quot;Simply upload the Excel sheet to make a prediction.&quot;)
                             )
                         ),
                         br(),
                         
                         strong(&quot;A: The following table represents prediction result for each sample.&quot;, 
                                style = &quot;color:#006666&quot;), br(),
                         dataTableOutput(&quot;batchPrediction.output1&quot;),
                         br(),
                         
                         strong(&quot;B: The following heatmap visualizes the above prediction table as easy overview.&quot;, 
                                style = &quot;color:#006666&quot;),
                         plotOutput(&quot;batchPrediction.output2&quot;)
                ),
                
                tabPanel(&quot;About&quot;,
                         br(),
                         fluidRow(
                             column(8,
                                    strong(span(&quot;For R script of this interactive application and more associated data analysis of our publication on African vegetables amino acids,
                                please visit our&quot;, a(&quot;R markdown code documents&quot;, href = &quot;https://yuanbofaith.github.io/AfricanVegetables_AminoAcids/index.html&quot;, &quot;.&quot;)),
                                           style = &quot;color: #666666&quot;)
                             )
                         )
                         
                )
            )
        )
    )
)





# Define server----
server &lt;- function(input, output) {
    
    # tab 1: Simulator
    
    ph  &lt;- eventReactive(input$Shuffle, {
        
        if (input$SeedBirthday == T) {set.seed(19911110)}
        
        withProgress(message = &quot;Modelling...&quot;, value = 0, {
            
            for(i in 1:length(progress)) {
                
                # update progress of step i
                incProgress(1/length(progress), detail = progress[i])
                # Pause for 1 sec to simulate a long computation.
                Sys.sleep(1)
                
                ## 70/30 train/test split ----
                if (i == 1){
                    
                    df.learn = func.strata.Norm.trainTest(trainingRatio = input$SplitRatio, scaleData = T) 
                    df.train = df.learn[[1]]
                    df.test = df.learn[[2]]
                    
                    colnames(df.train) = make.names(colnames(df.train))
                    colnames(df.test) = make.names(colnames(df.test))
                } 
                
                ## Linear discriminant analysis (LDA)----
                if (i == 2) {
                    mdl.trained.LDA = lda(Category ~., data = df.train)
                    mdl.fitted.LDA = predict(mdl.trained.LDA, newdata = df.test, prior = rep(1/4, 4))
                    fitted.LDA = mdl.fitted.LDA$class # here we overwrite the prior fitted.LDA object
                    cf.LDA = confusionMatrix(data = fitted.LDA, reference = df.test$Category, mode = &quot;everything&quot;)
                    
                    # confusion table and summary stats
                    cf.counts.LDA = cf.LDA$table %&gt;% func.tidy.cf.contigencyTable(ModelName = &quot;LDA&quot;)
                    cf.stats.LDA = cf.LDA$byClass %&gt;% func.tidy.cf.statsTable(ModelName = &quot;LDA&quot;) 
                }
                
                ## Quadratic discriminant analysis ----
                if (i == 3) {
                    mdl.QDA = qda(Category ~., data = df.train)
                    mdl.fitted.QDA = predict(mdl.QDA, newdata = df.test, prior = rep(1/4, 4))
                    fitted.QDA = mdl.fitted.QDA$class
                    cf.QDA = confusionMatrix(data = fitted.QDA, reference = df.test$Category, mode = &quot;everything&quot;)
                    
                    # confusion table and summary stats
                    cf.counts.QDA = cf.QDA$table %&gt;% func.tidy.cf.contigencyTable(ModelName = &quot;QDA&quot;) 
                    cf.stats.QDA = cf.QDA$byClass %&gt;% func.tidy.cf.statsTable(ModelName = &quot;QDA&quot;)
                    
                }
                
                ## Regularized logistic regression -----
                if (i == 4) {
                    
                    # Define function for performing regularized logistic with different alpha values
                    func.regularizedLogistic = function(
                        input.alpha, # control ridge, lasso, or between
                        ModelName    # model type as extra column note in the confusion table output
                    ){        # train with 10-fold cross validation
                        cv.mdl.logistic = cv.glmnet(x = df.train[, -1] %&gt;% as.matrix(), y = df.train$Category, 
                                                    family = &quot;multinomial&quot;, alpha = input.alpha, nfolds = 6)
                        # predict with test set
                        fitted.logistic =
                            predict(cv.mdl.logistic, newx = df.test[, -1] %&gt;% as.matrix(), 
                                    s = cv.mdl.logistic$lambda.1se, type = &quot;class&quot;) %&gt;% c() %&gt;% 
                            factor(levels = sort(unique.categories), ordered = T) # Note: important to sort unique.categories!
                        
                        # wrap up prediction results
                        cf.logistic = confusionMatrix(data = fitted.logistic, reference = df.test$Category)
                        cf.counts.logistic = cf.logistic$table %&gt;% func.tidy.cf.contigencyTable(ModelName = ModelName)
                        cf.stats.logistic = cf.logistic$byClass %&gt;% func.tidy.cf.statsTable(ModelName = ModelName)
                        
                        return(list(cf.counts.logistic, cf.stats.logistic, fitted.logistic, cf.logistic))
                        
                    }
                    
                    list.logistic = func.regularizedLogistic(input.alpha = 0.5, ModelName = paste(&quot;EN&quot;) )
                    cf.counts.ElasticNet =list.logistic[[1]]
                    cf.stats.ElasticNet = list.logistic[[2]]
                    fitted.ElasticNet = list.logistic[[3]]
                    cf.EN = list.logistic[[4]]
                    
                }
                
                ## Random forest ----
                if (i == 5) {
                    mdl.randomForest = randomForest(Category ~., data = df.train, ntree = 500, mtry = 5) 
                    fitted.randomForest = predict(mdl.randomForest, newdata = df.test)
                    
                    # set up confusion table
                    cf.randomForest = confusionMatrix(
                        data = fitted.randomForest, reference = df.test$Category, mode = &quot;everything&quot;)
                    # confusion matrix and summary stats
                    cf.counts.randomForest = cf.randomForest$table %&gt;%
                        func.tidy.cf.contigencyTable(ModelName = &quot;RF&quot;)
                    
                    cf.stats.randomForest = cf.randomForest$byClass %&gt;% 
                        func.tidy.cf.statsTable(ModelName = &quot;RF&quot;)
                    
                }
                
                ## Support vector machine ----
                if (i == 6) {
                    mdl.svm = svm(x = df.train[, -1], y = df.train$Category)
                    # predict
                    fitted.svm = predict(mdl.svm, newdata = df.test[, -1])
                    
                    # confusion matrix
                    cf.svm = confusionMatrix(
                        data = fitted.svm, reference = df.test$Category, mode = &quot;everything&quot;)
                    
                    # confusion matrix and summary stats
                    cf.counts.svm = cf.svm$table %&gt;%
                        func.tidy.cf.contigencyTable(ModelName = &quot;SVM&quot;)
                    
                    cf.stats.svm = cf.svm$byClass %&gt;% 
                        func.tidy.cf.statsTable(ModelName = &quot;SVM&quot;)
                    
                }
                
                
                ## Naive Bayes (benchmark) ----
                if(i == 7) {
                    mdl.Bayes = naiveBayes(x = df.train[, -1], y = df.train$Category)
                    
                    fitted.Bayes = predict(mdl.Bayes, newdata = df.test, type = &quot;class&quot;)
                    
                    # confusion matrix
                    cf.Bayes = confusionMatrix(
                        data = fitted.Bayes, reference = df.test$Category, mode = &quot;everything&quot;)
                    
                    # confusion matrix and summary stats
                    cf.counts.Bayes = cf.Bayes$table %&gt;%
                        func.tidy.cf.contigencyTable(ModelName = &quot;NB&quot;)
                    cf.stats.Bayes = cf.Bayes$byClass %&gt;% 
                        func.tidy.cf.statsTable(ModelName = &quot;NB&quot;)
                    
                }
                
                
                ## Wrap up results
                if (i == 8) {
                    # Test results ----
                    # Summary of all machine learning techniques ----
                    
                    # Sample wise prediction of all models and most voted 
                    df.actual.vs.fit = data.frame(
                        &quot;Actual&quot; = df.test$Category, 
                        &quot;LDA&quot; = fitted.LDA, 
                        &quot;QDA&quot; = fitted.QDA, 
                        &quot;EN&quot; = fitted.ElasticNet, 
                        # &quot;CART&quot; = fitted.CART,
                        &quot;RF&quot; =  fitted.randomForest, 
                        &quot;SVM&quot; =  fitted.svm, 
                        &quot;NB&quot; = fitted.Bayes)
                    
                    df.actual.vs.fit = df.actual.vs.fit %&gt;% as_tibble() %&gt;%
                        mutate(Actual = factor(Actual, ordered = F))
                    
                    df.actual.vs.fit = df.actual.vs.fit %&gt;% 
                        mutate(most.voted =  apply(df.actual.vs.fit %&gt;% select(-Actual),
                                                   MARGIN = 1, func.mostVotes))
                    
                    
                    # Most voted confusion matrix
                    cf.mostVoted = confusionMatrix(data = df.actual.vs.fit$most.voted %&gt;% factor(), 
                                                   reference = df.actual.vs.fit$Actual, mode = &quot;everything&quot;)
                    
                    cf.counts.MostVoted = cf.mostVoted$table %&gt;%
                        func.tidy.cf.contigencyTable(ModelName = &quot;Most voted&quot;)
                    
                    cf.stats.MostVoted = cf.mostVoted$byClass %&gt;%
                        func.tidy.cf.statsTable(ModelName = &quot;Most voted&quot;)
                    
                    
                    
                    
                    
                    # Summary of all machine learning techniques
                    df.confusionMatrix.all = cf.counts.LDA %&gt;% rbind(cf.counts.QDA) %&gt;%
                        rbind(cf.counts.ElasticNet) %&gt;% # rbind(cf.counts.CART) %&gt;%
                        rbind(cf.counts.randomForest) %&gt;% rbind(cf.counts.svm) %&gt;%
                        rbind(cf.counts.Bayes) %&gt;% rbind(cf.counts.MostVoted) %&gt;% as_tibble()
                    
                    
                    # tidy up the confusion matrix combined
                    df.confusionMatrix.all.tidy = df.confusionMatrix.all %&gt;%
                        # tidy up
                        gather(-c(Prediction, Model), key = reference, value = counts) %&gt;%
                        
                        # convert AIVs category into ordered factor
                        mutate(reference = factor(reference, levels = unique.categories, ordered = T),
                               Prediction = factor(Prediction, levels = unique.categories %&gt;% rev(), ordered = T)) %&gt;%
                        
                        # change model order in the dataset
                        mutate(Model = factor(Model, levels = unique.models, ordered = T)) %&gt;%
                        arrange(Model, reference, Prediction) %&gt;%
                        mutate(Diaganol = Prediction == reference)
                    
                    
                    
                    
                    ## Plot confusion matrix
                    # Assign color to correct / incorrect prediction
                    diag = df.confusionMatrix.all.tidy %&gt;% 
                        filter(Diaganol == F)
                    
                    df.confusionMatrix.all.tidy = diag %&gt;% 
                        mutate(color = ifelse(counts == 0, &quot;Grey&quot;, &quot;Firebrick&quot;)) %&gt;%
                        rbind(df.confusionMatrix.all.tidy %&gt;% filter(Diaganol == T) %&gt;%
                                  mutate(color = &quot;steelblue&quot;))
                  
                    
                    # Set up summary statistics
                    df.stats = cf.stats.LDA %&gt;% rbind(cf.stats.QDA) %&gt;%
                        rbind(cf.stats.ElasticNet) %&gt;% rbind(cf.stats.randomForest) %&gt;%
                        rbind(cf.stats.svm) %&gt;% rbind(cf.stats.Bayes) %&gt;% rbind(cf.stats.MostVoted) %&gt;%
                        select(Category, Model, Precision, Recall, F1) %&gt;% 
                        gather(-c(1:2), key = metrics, value = values) %&gt;%
                        mutate(Model = factor(Model, levels = unique.models, ordered = T))
                    
                    
                    df.stats.overal = func.tidy.cf.statsOveral(cf.LDA$overall, modelName = &quot;LDA&quot;) %&gt;%
                        rbind(func.tidy.cf.statsOveral(cf.QDA$overall, modelName = &quot;QDA&quot;)) %&gt;%
                        rbind(func.tidy.cf.statsOveral(cf.EN$overall, modelName = &quot;EN&quot;)) %&gt;%
                        rbind(func.tidy.cf.statsOveral(cf.randomForest$overall, modelName = &quot;RF&quot;)) %&gt;%
                        rbind(func.tidy.cf.statsOveral(cf.svm$overall, modelName = &quot;SVM&quot;)) %&gt;%
                        rbind(func.tidy.cf.statsOveral(cf.Bayes$overall, modelName = &quot;NB&quot;)) %&gt;%
                        rbind(func.tidy.cf.statsOveral(cf.mostVoted$overall, modelName = &quot;Most voted&quot;)) %&gt;%
                        mutate(Model = factor(Model, levels = unique.models, ordered = T))
                    
                }
                
                ## Visualization ----
                if (i == 9) {
                    # confusion matrix -----
                    p =   df.confusionMatrix.all.tidy %&gt;% # --------
                    ggplot(aes(x = reference, y = Prediction)) + 
                        facet_wrap(~Model, nrow = 2) +
                        
                        # off diaganol incorrect prediction
                        geom_label(data = df.confusionMatrix.all.tidy %&gt;% filter(color == &quot;Firebrick&quot;),
                                   aes(label = counts), 
                                   fill = &quot;firebrick&quot;, alpha = .3, size = 6) +
                        
                        # diaganol correct prediction
                        geom_label(data = df.confusionMatrix.all.tidy %&gt;% filter(color == &quot;steelblue&quot;),
                                   aes(label = counts),
                                   fill = &quot;Steelblue&quot;, alpha = .3, size = 6) +
                        
                        # zero counts
                        geom_label(data = df.confusionMatrix.all.tidy %&gt;% filter(color == &quot;Grey&quot;),
                                   aes(label = counts), 
                                   size = 6, color = &quot;grey&quot;)  +
                        theme_bw() +
                        
                        theme(axis.text.x = element_text(angle = 90, vjust = .8, hjust = .8, color = &quot;black&quot;, size = 12),
                              axis.text.y = element_text(color = &quot;black&quot;, size = 12),
                              axis.title = element_text(size = 14, colour = &quot;black&quot;),
                              strip.background = element_blank(),
                              strip.text = element_text(face = &quot;bold&quot;, size = 14),
                              panel.border = element_rect(color = &quot;black&quot;, size = 1),
                              title = element_text(face = &quot;bold&quot;)) + 
                        labs(x = &quot;\nReference&quot;, y = &quot;Prediction\n&quot;) 
                    
                    
                    # sample-wise comparison heatmap -----
                    df.actual.vs.fit = data.frame(
                        &quot;Actual&quot; = df.test$Category, 
                        &quot;LDA&quot; = fitted.LDA, 
                        &quot;QDA&quot; = fitted.QDA, 
                        &quot;EN&quot; = fitted.ElasticNet, 
                        # &quot;CART&quot; = fitted.CART,
                        &quot;RF&quot; =  fitted.randomForest, 
                        &quot;SVM&quot; =  fitted.svm, 
                        &quot;NB&quot; = fitted.Bayes)
                    
                    df.actual.vs.fit = df.actual.vs.fit %&gt;% as_tibble() %&gt;%
                        mutate(Actual = factor(Actual, ordered = F))
                    df.actual.vs.fit
                    
                    df.actual.vs.fit = df.actual.vs.fit %&gt;% 
                        mutate(most.voted =  apply(df.actual.vs.fit %&gt;% select(-Actual),
                                                   MARGIN = 1, func.mostVotes))
                    
                    
                    # Heatmap of sample-wise predicted result
                    plt.heatmap.machineLearning = 
                        df.actual.vs.fit %&gt;% arrange(Actual) %&gt;%
                        as.matrix() %&gt;% t() %&gt;%
                        Heatmap(col = color.category,
                                heatmap_legend_param = list(
                                    title = &quot;&quot;, title_position = &quot;leftcenter&quot;,
                                    nrow = 1,
                                    labels_gp = gpar(fontsize = 15)), 
                                rect_gp = gpar(col = &quot;white&quot;, lwd = 0.1))
                    
                    h = draw(plt.heatmap.machineLearning, heatmap_legend_side = &quot;bottom&quot;)
                    
                    
                    
                    # Summary statistics
                    plt.summaryStats = 
                        df.stats %&gt;% ggplot(aes(x = Category, y = values, color = metrics)) +
                        geom_segment(aes( xend = Category, y = 0.5, yend = values), 
                                     position = position_dodge(0.5)) +
                        geom_point(size = 4, position = position_dodge(.3), alpha = .9) +
                        facet_wrap(~Model, nrow = 1) +
                        theme_bw() +
                        theme(legend.position = &quot;bottom&quot;,
                              legend.title = element_text(size = 14),
                              legend.text = element_text(size = 14),
                              
                              strip.text = element_text(face = &quot;bold&quot;, size = 14),
                              strip.background = element_blank(),
                              
                              axis.text.x = element_text(angle = 90, hjust = 1, colour = &quot;black&quot;, size = 12),
                              axis.text.y = element_text(colour = &quot;black&quot;, size = 12),
                              axis.title = element_text(size = 13)) +
                        coord_cartesian(ylim = c(0.65, 1)) +
                        scale_color_brewer(palette = &quot;Accent&quot;) +
                        
                        # overal stats
                        geom_text(data = df.stats.overal, 
                                  aes(x = 2.5, y = 0.7, label = round(Accuracy, 3) * 100), 
                                  color = &quot;black&quot;, fontface = &quot;bold&quot;, size = 6) +
                        
                        geom_text(data = df.stats.overal, 
                                  aes(x = 2.5, y = 0.66, 
                                      label = paste(round(AccuracyLower, 3) * 100, &quot; ~ &quot;,
                                                    round(AccuracyUpper, 3) * 100)), 
                                  color = &quot;black&quot;, size = 5) 
                } 
            }
        })
        return(list(p, h, plt.summaryStats))
    })
    
    output$plt.newShuffle = renderPlot({  ph()[[1]] })
    output$plt.newShuffle.heatmap = renderPlot({  ph()[[2]] })
    output$plt.summaryStats = renderPlot({ ph()[3] })
    
    
    
    
    
    # tab 2: Single prediction of real unknown sample
    plt.singleSample.predict = eventReactive(input$Predict2, {
        
        withProgress(message = &quot;Modelling...&quot;, value = 0, {
            
            for(i in 1:length(progress)) {
                
                # update progress of step i
                incProgress(1/length(progress), detail = progress[i])
                # Pause for 1 sec to simulate a long computation.
                Sys.sleep(1)
                
                # Use all oroginal dataset for training models
                if (i == 1){
                    
                    # model training
                    df.train = func.strata.Norm.trainTest(trainingRatio = 1, scaleData = T)[[1]] # split ratio = 1
                    
                    # collect to-predict feature space
                    df.singleInput = data.frame(
                        
                        leucine = input$leucine,             isoleucine = input$isoleucine,         tryptophan = input$tryptophan,
                        phenylalanine = input$phenylalanine, valine = input$valine,                 methionine = input$methionine, 
                        
                        tyrosine = input$tyrosine,           proline = input$proline,               alanine = input$alanine, 
                        cysteine = input$cysteine,           glycine = input$glycine,               glutamic.acid = input$glutamic.acid, 
                        
                        threonine = input$threonine,         hydroxyproline = input$hydroxyproline, glutamine = input$glutamine,
                        aspartic.acid = input$aspartic.acid, serine = input$serine,                 asparagine = input$asparagine, 
                        
                        arginine = input$arginine,           histidine = input$histidine,           lysine = input$lysine
                        
                    ) %&gt;% as_tibble()
                    
                    # Normalize unknown sample based on mean and standard deviation vector computed from entire original AIV dataset
                    # Meanwhile overwriting the input feature space
                    df.singleInput = df.singleInput %&gt;% 
                        scale(center = df.summaryALL$content.mean, scale = df.summaryALL$content.sd) %&gt;%
                        as_tibble()
                } 
                
                ## Linear discriminant analysis (LDA)----
                if (i == 2) {
                    mdl.trained.LDA = lda(Category ~., data = df.train)
                    mdl.fitted.LDA = predict(mdl.trained.LDA, newdata = df.singleInput, prior = rep(1/4, 4))
                    fitted.LDA = mdl.fitted.LDA$class 
                }
                ## Quadratic discriminant analysis  
                if (i == 3) {
                    mdl.QDA = qda(Category ~., data = df.train)
                    mdl.fitted.QDA = predict(mdl.QDA, newdata = df.singleInput, prior = rep(1/4, 4))
                    fitted.QDA = mdl.fitted.QDA$class
                }
                ## Regularized logistic regression 
                if (i == 4) {
                    cv.mdl.ElasticNet = cv.glmnet(x = df.train[, -1] %&gt;% as.matrix(), y = df.train$Category, 
                                                  family = &quot;multinomial&quot;, alpha = .5, nfolds = 6)
                    
                    fitted.ElasticNet = predict(cv.mdl.ElasticNet, newx = df.singleInput %&gt;% as.matrix(), 
                                                s = cv.mdl.ElasticNet$lambda.1se, type = &quot;class&quot;)
                }
                ## Random forest 
                if (i == 5) {
                    mdl.randomForest = randomForest(Category ~., data = df.train, ntree = 500, mtry = 5) 
                    fitted.randomForest = predict(mdl.randomForest, newdata = df.singleInput)
                }
                ## Support vector machine
                if (i == 6) {
                    mdl.svm = svm(x = df.train[, -1], y = df.train$Category)
                    # predict
                    fitted.svm = predict(mdl.svm, newdata = df.singleInput)
                }
                ## Naive Bayes (benchmark) ----
                if(i == 7) {
                    mdl.Bayes = naiveBayes(x = df.train[, -1], y = df.train$Category)
                    fitted.Bayes = predict(mdl.Bayes, newdata = df.singleInput, type = &quot;class&quot;)
                }
                
                ## Wrap up results
                if (i == 8) {
                    # As column names, no space allowed in header names. Thus use underscore later replace with space
                    t = data.frame(&quot;Linear_discriminant_analysis&quot; = fitted.LDA, 
                                   &quot;Quadratic_discriminant_analysis&quot; = fitted.QDA, 
                                   &quot;Elastic_net&quot; = fitted.ElasticNet, 
                                   &quot;Random_forest&quot; = fitted.randomForest, 
                                   &quot;Support_vector_machine&quot; = fitted.svm, 
                                   &quot;Naive_Bayes&quot; = fitted.Bayes) %&gt;% 
                        as_tibble() %&gt;% gather(key = model, value = result) %&gt;%
                        mutate(model = str_replace_all(model, pattern = &quot;_&quot;, replacement = &quot; &quot;),
                               model = factor(model, levels = unique.models2, ordered = T))
                    
                }
                
                if (i == 9) {
                    p2 = t %&gt;% gather(key = model, value = result) %&gt;%
                        ggplot(aes(x = 1, y = 1, fill = result)) + 
                        geom_label(aes(label = result),
                                   size = 7, alpha = 1, color = &quot;white&quot;, fontface = &quot;bold&quot;,
                                   label.padding = unit(1, &quot;lines&quot;), # padding size
                                   label.r = unit(1, &quot;lines&quot;)) + # rounding corder
                        facet_wrap(~model) +
                        scale_fill_manual(values = color.category) +
                        theme_minimal() +  
                        theme(plot.background =  element_blank(), 
                              axis.title = element_blank(), axis.text = element_blank(),
                              strip.text = element_text(face = &quot;bold&quot;, size = 16, color = &quot;#666666&quot;),
                              legend.position = &quot;NA&quot;) +
                        coord_flip() +  coord_fixed(.5)
                    
                    
                }
            }
        })
        return(p2)
    })
    
    output$plt.singleSamplePredict = renderPlot({  plt.singleSample.predict() })
    
    
    
    
    
    
    # tab 3: Batch prediction of real unknown samples
    
    
    tab3.output = eventReactive(input$userfile, {
        
        # Read user-input excel file
        infile &lt;- input$userfile
        df.batchPredict &lt;- read_excel(infile$datapath)
        
        df.batchPredict.featureSpace.scaled = df.batchPredict[, -1] %&gt;% 
            scale(center = df.summaryALL$content.mean, scale = df.summaryALL$content.sd) %&gt;%
            as_tibble()
        
        
        withProgress(message = &quot;Modelling...&quot;, value = 0, {
            
            for(i in 1:length(progress)) {
                
                # update progress of step i
                incProgress(1/length(progress), detail = progress[i])
                # Pause for 1 sec to simulate a long computation.
                Sys.sleep(1)
                
                # Use all oroginal dataset for training models
                if (i == 1){
                    
                    # model training
                    df.train = func.strata.Norm.trainTest(trainingRatio = 1, scaleData = T)[[1]] # split ratio = 1
                    
                    
                    # Normalize unknown batch based on mean and standard deviation vector computed from entire original AIV dataset
                    df.batchPredict.featureSpace.scaled = df.batchPredict[, -1] %&gt;% 
                        scale(center = df.summaryALL$content.mean, scale = df.summaryALL$content.sd) %&gt;%
                        as_tibble()
                } 
                
                ## Linear discriminant analysis (LDA)----
                if (i == 2) {
                    mdl.trained.LDA = lda(Category ~., data = df.train)
                    mdl.fitted.LDA = predict(mdl.trained.LDA, newdata = df.batchPredict.featureSpace.scaled, prior = rep(1/4, 4))
                    fitted.LDA = mdl.fitted.LDA$class 
                }
                ## Quadratic discriminant analysis  
                if (i == 3) {
                    mdl.QDA = qda(Category ~., data = df.train)
                    mdl.fitted.QDA = predict(mdl.QDA, newdata = df.batchPredict.featureSpace.scaled, prior = rep(1/4, 4))
                    fitted.QDA = mdl.fitted.QDA$class
                }
                ## Regularized logistic regression 
                if (i == 4) {
                    cv.mdl.ElasticNet = cv.glmnet(x = df.train[, -1] %&gt;% as.matrix(), y = df.train$Category, 
                                                  family = &quot;multinomial&quot;, alpha = .5, nfolds = 6)
                    
                    fitted.ElasticNet = predict(cv.mdl.ElasticNet, newx = df.batchPredict.featureSpace.scaled %&gt;% as.matrix(), 
                                                s = cv.mdl.ElasticNet$lambda.1se, type = &quot;class&quot;)
                }
                ## Random forest 
                if (i == 5) {
                    mdl.randomForest = randomForest(Category ~., data = df.train, ntree = 500, mtry = 5) 
                    fitted.randomForest = predict(mdl.randomForest, newdata = df.batchPredict.featureSpace.scaled)
                }
                ## Support vector machine
                if (i == 6) {
                    mdl.svm = svm(x = df.train[, -1], y = df.train$Category)
                    # predict
                    fitted.svm = predict(mdl.svm, newdata = df.batchPredict.featureSpace.scaled)
                }
                ## Naive Bayes (benchmark) ----
                if(i == 7) {
                    mdl.Bayes = naiveBayes(x = df.train[, -1], y = df.train$Category)
                    fitted.Bayes = predict(mdl.Bayes, newdata = df.batchPredict.featureSpace.scaled, type = &quot;class&quot;)
                }
                
                ## Wrap up results
                if (i == 8) {
                    # Summary table -----
                    d.fitted.all = data.frame(&quot;LDA&quot; = fitted.LDA, 
                                              &quot;QDA&quot; = fitted.QDA, 
                                              &quot;EN&quot; = fitted.ElasticNet %&gt;% c(), 
                                              &quot;RF&quot; = fitted.randomForest, 
                                              &quot;SVM&quot; = fitted.svm, 
                                              &quot;NB&quot; = fitted.Bayes) 
                    # summarize most voted
                    d.fitted.all = d.fitted.all %&gt;% 
                        mutate(most.voted = apply(d.fitted.all, MARGIN = 1, func.mostVotes)) 
                    
                    # combine sample name with prediction result as output table
                    d.fitted.all.named.1 = cbind(Sample = df.batchPredict$Sample, d.fitted.all) 
                    
                }
            }
            
        })
        return(list(d.fitted.all.named.1) )
    }) 
    
    output$batchPrediction.output1 = renderDataTable(tab3.output()[[1]] )
    
    
    
    
    # Heatmap of sample-wise predicted result -----
    # rownames(d.fitted.all) = df.batchPredict$Sample
    
    tab3.heatmap = reactive({
        d.heat = tab3.output()[[1]]
        
        if (input$ArrangeCategory == TRUE) { # arrange by category order
            
            d.heat = d.heat %&gt;% 
                mutate(most.voted = factor(most.voted, levels = unique.categories, ordered = T)) %&gt;%
                arrange(most.voted) 
            SampleNames = d.heat$Sample
            d.heat = d.heat %&gt;% select(-Sample) %&gt;% as.matrix()
            rownames(d.heat) = SampleNames
        } else{ # keep original order
            SampleNames = d.heat$Sample
            d.heat = d.heat %&gt;% select(-Sample) %&gt;% as.matrix()
            rownames(d.heat) = SampleNames
        }
        
        plt.heatmap.batchPrediction = 
            d.heat %&gt;% t() %&gt;%
            Heatmap(col = color.category,
                    heatmap_legend_param = list(
                        title = &quot;&quot;, title_position = &quot;leftcenter&quot;,
                        nrow = 1,
                        labels_gp = gpar(fontsize = 15)), 
                    rect_gp = gpar(col = &quot;white&quot;, lwd = 0.1))
        
        kk = draw(plt.heatmap.batchPrediction, heatmap_legend_side = &quot;bottom&quot;)
        return(kk)
    })
    
    
    output$batchPrediction.output2 = renderPlot(tab3.heatmap())
    
    
    
    # download template
    
    df.template = drop_read_csv(file = &quot;Template for batch prediction.csv&quot;)
    
    output$downloadTemplate = downloadHandler(
        filename = &quot;Template for batch prediction.xlsx&quot;,
        content = function(file) {
            write_xlsx(df.template, path = file)  
        } 
    )
    
    # download predicted table
    output$downloadPredicted = downloadHandler(
        filename = &quot;Predicted results.xlsx&quot;,
        content = function(file) {
            write_xlsx(tab3.output()[[1]], path = file )
        }
    )
    
}

shinyApp(ui, server)</code></pre>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
